import os
os.makedirs(".", exist_ok=True)
os.makedirs("domain", exist_ok=True)
if not os.path.exists("domain\crossorigin.py"):
  with open("domain\crossorigin.py", 'w+') as f:
      f.write("+import os")
      f.write("+")
      f.write("+from sqlalchemy import Boolean, Column, ForeignKey, Integer, String, Date, Time, TIMESTAMP, DateTime, func, case, Float, text")
      f.write("+from sqlalchemy.orm import column_property, relationship, deferred, Session")
      f.write("+from sqlalchemy.ext.declarative import declarative_base")
      f.write("+from sqlalchemy.ext.hybrid import hybrid_property")
      f.write("+")
      f.write("+from core.db import Base")
      f.write("+from core.db.mixins import TimestampLogMixin")
      f.write("+")
      f.write("+")
      f.write("+class CrossOrigin(Base, TimestampLogMixin):")
      f.write("+    __tablename__ = \"sys_cross_origin"")
      f.write("+")
      f.write("+    id = Column(Integer, primary_key=True, index=True, autoincrement=True)")
      f.write("+    link = Column(String(64), unique=True, index=True)")
      f.write("+")
      f.write("+    @classmethod")
      f.write("+    def create(cls, link: str) -> \"CrossOrigin":")
      f.write("+        return cls(link=link)")
if not os.path.exists("domain\__init__.py"):
  with open("domain\__init__.py", 'w+') as f:
      f.write("+from .crossorigin import CrossOrigin")
      f.write("+")
      f.write("+__all__ = [\"CrossOrigin"]")
os.makedirs("exceptions", exist_ok=True)
if not os.path.exists("exceptions\crossorigin.py"):
  with open("exceptions\crossorigin.py", 'w+') as f:
      f.write("+from core.exceptions import CustomException")
      f.write("+")
      f.write("+")
      f.write("+class CrossOriginDuplicateException(CustomException):")
      f.write("+    code = 400")
      f.write("+    error_code = 10400")
      f.write("+    message = \"link already created"")
      f.write("+")
      f.write("+")
      f.write("+class CrossOriginNotFoundException(CustomException):")
      f.write("+    code = 404")
      f.write("+    error_code = 10401")
      f.write("+    message = \"link origin not found"")
if not os.path.exists("exceptions\__init__.py"):
  with open("exceptions\__init__.py", 'w+') as f:
      f.write("+from .crossorigin import CrossOriginDuplicateException, CrossOriginNotFoundException")
      f.write("+")
      f.write("+__all__ = [\"CrossOriginDuplicateException", "CrossOriginNotFoundException"]")
os.makedirs("repository", exist_ok=True)
if not os.path.exists("repository\crossorigin.py"):
  with open("repository\crossorigin.py", 'w+') as f:
      f.write("+from typing import Optional, List, Union")
      f.write("+from datetime import datetime")
      f.write("+")
      f.write("+from abc import ABCMeta, abstractmethod")
      f.write("+from sqlalchemy import or_, select")
      f.write("+from sqlalchemy.ext.asyncio import AsyncSession")
      f.write("+from sqlalchemy.exc import SQLAlchemyError")
      f.write("+")
      f.write("+from app._sys.crossorigin.domain import CrossOrigin")
      f.write("+from core.db import session")
      f.write("+from core.exceptions import DatabaseSavingException, DatabaseUpdatingException, DatabaseDeletingException")
      f.write("+")
      f.write("+")
      f.write("+class CrossOriginRepo:")
      f.write("+")
      f.write("+    __metaclass__ = ABCMeta")
      f.write("+")
      f.write("+    @abstractmethod")
      f.write("+    async def get(self, link: str) -> Optional[CrossOrigin]:")
      f.write("+        pass")
      f.write("+")
      f.write("+    @abstractmethod")
      f.write("+    async def get_by_id(self, crossorigin_id: int) -> Optional[CrossOrigin]:")
      f.write("+        pass")
      f.write("+")
      f.write("+    @abstractmethod")
      f.write("+    async def save(self, crossorigin: CrossOrigin) -> CrossOrigin:")
      f.write("+        pass")
      f.write("+")
      f.write("+    @abstractmethod")
      f.write("+    async def update(self, crossorigin: CrossOrigin, **kwargs) -> CrossOrigin:")
      f.write("+        pass")
      f.write("+")
      f.write("+    @abstractmethod")
      f.write("+    async def delete(self, crossorigin: CrossOrigin, deleted_user: str) -> None:")
      f.write("+        pass")
      f.write("+")
      f.write("+")
      f.write("+class CrossOriginSQLRepo(CrossOriginRepo):")
      f.write("+    async def get(self, link: str) -> Optional[CrossOrigin]:")
      f.write("+        result = await session.execute(select(CrossOrigin).where(CrossOrigin.link == link))")
      f.write("+        return result.scalars().first()")
      f.write("+")
      f.write("+    async def get_by_id(self, crossorigin_id: int) -> Optional[CrossOrigin]:")
      f.write("+        return await session.get(CrossOrigin, crossorigin_id)")
      f.write("+")
      f.write("+    async def save(self, crossorigin: CrossOrigin) -> CrossOrigin:")
      f.write("+        try:")
      f.write("+            await session.add(crossorigin)")
      f.write("+            await session.commit()")
      f.write("+            await session.refresh(crossorigin)")
      f.write("+            return crossorigin")
      f.write("+        except SQLAlchemyError as e:")
      f.write("+            await session.rollback()")
      f.write("+            raise DatabaseSavingException(f\"Error saving crossorigin: {str(e)}")")
      f.write("+")
      f.write("+    async def update(self, crossorigin: CrossOrigin, **kwargs) -> CrossOrigin:")
      f.write("+        try:")
      f.write("+            for key, value in kwargs.items():")
      f.write("+                if hasattr(crossorigin, key) and value is not None:")
      f.write("+                    setattr(crossorigin, key, value)")
      f.write("+            await session.commit()")
      f.write("+            await session.refresh(crossorigin)")
      f.write("+            return crossorigin")
      f.write("+        except SQLAlchemyError as e:")
      f.write("+            await session.rollback()")
      f.write("+            raise DatabaseUpdatingException(f\"Error updating crossorigin: {str(e)}")")
      f.write("+")
      f.write("+    async def delete(self, crossorigin: CrossOrigin, deleted_user: str) -> None:")
      f.write("+        try:")
      f.write("+            if not crossorigin.deleted_at:")
      f.write("+                crossorigin.deleted_at = datetime.now()")
      f.write("+                crossorigin.deleted_user = deleted_user")
      f.write("+                await session.commit()")
      f.write("+        except SQLAlchemyError as e:")
      f.write("+            await session.rollback()")
      f.write("+            raise DatabaseDeletingException(f\"Error deleting crossorigin: {str(e)}")")
if not os.path.exists("repository\__init__.py"):
  with open("repository\__init__.py", 'w+') as f:
      f.write("+from .crossorigin import CrossOriginRepo, CrossOriginSQLRepo")
      f.write("+")
      f.write("+__all__ = [\"CrossOriginRepo", "CrossOriginSQLRepo"]")
os.makedirs("schema", exist_ok=True)
if not os.path.exists("schema\crossorigin.py"):
  with open("schema\crossorigin.py", 'w+') as f:
      f.write("+from datetime import datetime")
      f.write("+from typing import Optional")
      f.write("+from pydantic import BaseModel, Field")
      f.write("+")
      f.write("+")
      f.write("+class CrossOriginSchema(BaseModel):")
      f.write("+    id: int = Field(None, description=\"ID")")
      f.write("+    link: str = Field(None, description=\"allowed link")")
if not os.path.exists("schema\__init__.py"):
  with open("schema\__init__.py", 'w+') as f:
      f.write("+from .crossorigin import CrossOriginSchema")
      f.write("+")
      f.write("+__all__ = [\"CrossOriginSchema"]")
os.makedirs("service", exist_ok=True)
if not os.path.exists("service\crossorigin_command.py"):
  with open("service\crossorigin_command.py", 'w+') as f:
      f.write("+from typing import Union")
      f.write("+from pythondi import inject")
      f.write("+")
      f.write("+from app._sys.crossorigin.domain import CrossOrigin")
      f.write("+from app._sys.crossorigin.repository import CrossOriginRepo")
      f.write("+from app._sys.crossorigin.schema import CrossOriginSchema")
      f.write("+from app._sys.crossorigin.exceptions import CrossOriginNotFoundException, CrossOriginDuplicateException")
      f.write("+")
      f.write("+")
      f.write("+class CrossOriginCommandService:")
      f.write("+    @inject()")
      f.write("+    def __init__(self, crossorigin_repo: CrossOriginRepo):")
      f.write("+        self.crossorigin_repo = crossorigin_repo")
      f.write("+")
      f.write("+    async def create_crossorigin(self, link: str) -> CrossOriginSchema:")
      f.write("+        if await self.crossorigin_repo.get(link):")
      f.write("+            raise CrossOriginDuplicateException")
      f.write("+        data_create = CrossOrigin.create(link=link)")
      f.write("+        data_saved = await self.crossorigin_repo.save(crossorigin=data_create)")
      f.write("+        return data_saved")
      f.write("+")
      f.write("+    async def update_crossorigin(self, crossorigin_id: int, link: Union[str, None]) -> CrossOriginSchema:")
      f.write("+        data_get = await self.crossorigin_repo.get_by_id(crossorigin_id)")
      f.write("+        if not data_get:")
      f.write("+            raise CrossOriginNotFoundException")
      f.write("+        if await self.crossorigin_repo.get(link):")
      f.write("+            raise CrossOriginDuplicateException")
      f.write("+")
      f.write("+        updates = {}")
      f.write("+        if link:")
      f.write("+            updates[\"link"] = link")
      f.write("+")
      f.write("+        data_updated = await self.crossorigin_repo.update(data_get, updates)")
      f.write("+        return data_updated")
      f.write("+")
      f.write("+    async def delete_crossorigin(self, crossorigin_id: int, username: str) -> None:")
      f.write("+        data_get = await self.crossorigin_repo.get_by_id(crossorigin_id)")
      f.write("+        if not data_get:")
      f.write("+            raise CrossOriginNotFoundException")
      f.write("+")
      f.write("+        await self.crossorigin_repo.delete(data_get, username)")
if not os.path.exists("service\__init__.py"):
  with open("service\__init__.py", 'w+') as f:
      f.write("+from .crossorigin_command import CrossOriginCommandService")
      f.write("+from .crossorigin_query import CrossOriginQueryService")
      f.write("+")
      f.write("+__all__ = [\"CrossOriginCommandService", "CrossOriginQueryService"]")